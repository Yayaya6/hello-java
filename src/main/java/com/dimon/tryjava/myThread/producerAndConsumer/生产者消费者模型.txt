

什么是生产者/消费者模型

一种重要的模型，基于等待/通知机制。
生产者/消费者模型描述的是有一块缓冲区作为仓库，生产者可将产品放入仓库，消费者可以从仓库中取出产品，生产者/消费者模型关注的是以下几个点：

- 生产者生产的时候消费者不能消费
- 消费者消费的时候生产者不能生产
- 缓冲区空时消费者不能消费
- 缓冲区满时生产者不能生产


生产者/模型作为一种重要的模型，它的优点在于：
- 解耦。
  因为多了一个缓冲区，所以生产者和消费者并不直接相互调用，这一点很容易想到，
  这样生产者和消费者的代码发生变化，都不会对对方产生影响，这样其实就把生产者和消费者之间的强耦合解开，
  变为了生产者和缓冲区/消费者和缓冲区之间的弱耦合

- 通过平衡生产者和消费者的处理能力来提高整体处理数据的速度，这是生产者/消费者模型最重要的一个优点。
  如果消费者直接从生产者这里拿数据，如果生产者生产的速度很慢，但消费者消费的速度很快，
  那消费者就得占用CPU的时间片白白等在那边。有了生产者/消费者模型，生产者和消费者就是两个独立的并发体，
  生产者把生产出来的数据往缓冲区一丢就好了，不必管消费者；消费者也是，从缓冲区去拿数据就好了，也不必管生产者，
  缓冲区满了就不生产，缓冲区空了就不消费，使生产者/消费者的处理能力达到一个动态的平衡


小心假死

生产者/消费者模型最终达到的目的是平衡生产者和消费者的处理能力，达到这个目的的过程中，并不要求只有一个生产者和一个消费者。
可以多个生产者对应多个消费者，可以一个生产者对应一个消费者，可以多个生产者对应一个消费者。

假死就发生在上面三种场景下。理论分析就能说明问题，所以就不写代码了。
代码要写也很简单，上面的两个例子随便修改一个，
开一个生产者线程/多个消费者线程、开多个生产者线程/消费者线程、
开多个生产者线程/多个消费者线程都可以。
假死指的是全部线程都进入了WAITING状态，那么程序就不再执行任何业务功能了，整个项目呈现停滞状态。

比方说有生产者A和生产者B，缓冲区由于空了，消费者处于WAITING。
生产者B处于WAITING，生产者A被消费者通知生产，生产者A生产出来的产品本应该通知消费者，结果通知了生产者B，
生产者B被唤醒，发现缓冲区满了，于是继续WAITING。
至此，两个生产者线程处于WAITING，消费者处于WAITING，系统假死。


上面的分析可以看出，假死出现的原因是因为notify的是同类，所以非单生产者/单消费者的场景，可以采取两种方法解决这个问题：
1、synchronized用notifyAll()唤醒所有线程、ReentrantLock用signalAll()唤醒所有线程
2、用ReentrantLock定义两个Condition，一个表示生产者的Condition，一个表示消费者的Condition，
  唤醒的时候调用相应的Condition的signal()方法就可以了